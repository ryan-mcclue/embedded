#!/bin/bash

set -oue pipefail

print_metrics() {
  if [[ "$BUILD_TYPE" == "app" ]]; then
    : '
    flow_lines=()
    while IFS= read -r flow_line; do
      flow_lines+=( "$flow_line" )
    done < <(cflow --include-dir=external code/linux-main.cpp --omit-arguments --omit-symbol-name 2>/dev/null)
  
    function_names=()
    function_call_count=()
    for ((i = 0 ; i < ${#flow_lines[@]}; i++)); do
      line_length=${#flow_lines[$i]}
      read lstrip_line <<< "${flow_lines[$i]}"
      function_name="${lstrip_line%% *}"
      lstrip_line_length=${#lstrip_line}
      line_indentation=$(( line_length - lstrip_line_length ))
      printf "function: %s, indentation: %d\n" "$function_name" $line_indentation
    done
    '
  
    # IMPORTANT(Ryan): Must run with universal ctags
    ctags --c-kinds=f --fields=+ne -o - code/* | awk '
    BEGIN { 
      max_line_range = 0
      max_function_name = ""
      line_start_temp = 0
      line_end_temp = 0
      max_line_range_temp = 0
    }
    {
      for (i = 1; i <= NF; i++) {
        if (index($i, "line:") != 0) {
          line_start_temp = substr($i, 6)
        }
      if (index($i, "end:") != 0) {
        line_end_temp = substr($i, 5)
      }
    }
    max_line_range_temp = line_end_temp - line_start_temp 
    if (max_line_range_temp >= max_line_range) {
      max_line_range = max_line_range_temp
      max_function_name = $1
    }
    } END {
      printf("Longest function %s():%d lines\n", max_function_name, max_line_range)
    }
    '
  
    lines_of_code=$(cat code/* | wc -l)
    printf "LOC: %d\n" $lines_of_code
  
    # IMPORTANT(Ryan): This does not show debug information
    # Also assuming .bss negligable due to zero intialisation paradigm
    size build/linux-main | awk 'FNR == 2 { printf "text + data = %dkb\n", $4/1024 }'
  fi
